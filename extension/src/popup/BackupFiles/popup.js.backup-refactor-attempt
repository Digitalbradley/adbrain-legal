// Utility function for debouncing 
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Character counter function
window.updateCharCount = function(element, maxLength) {
    const content = element.innerText || element.textContent;
    const charCount = content.length;
    const countDisplay = element.nextElementSibling;
    const isDescription = element.dataset.field === 'description';
    const minRequired = isDescription ? 90 : 25;
    
    countDisplay.textContent = `${charCount}/${maxLength}`;
    
    // Color the count red if under minimum
    if (charCount < minRequired) {
        countDisplay.style.color = '#dc3545'; // Red
    } else if (charCount > maxLength) {
        countDisplay.style.color = '#dc3545'; // Red
    } else {
        countDisplay.style.color = '#28a745'; // Green
    }
};

class MonitoringSystem {
    constructor() {
        this.currentVersion = '1.0.0';
        this.startTime = new Date();
        
        // Initialize storage for metrics
        this.metrics = {
            operations: [],
            errors: [],
            featureUsage: {}
        };
    }

    logOperation(operation, status, details = {}) {
        const entry = {
            timestamp: new Date(),
            operation,
            status,
            details,
            version: this.currentVersion
        };
        
        console.log(`[Monitor] ${operation}:`, status);
        this.metrics.operations.push(entry);
        
        // Track feature usage
        this.metrics.featureUsage[operation] = 
            (this.metrics.featureUsage[operation] || 0) + 1;
    }

    logError(error, context) {
        const entry = {
            timestamp: new Date(),
            context,
            error: error.message,
            stack: error.stack,
            version: this.currentVersion
        };
        
        console.error(`[Monitor] Error in ${context}:`, error);
        this.metrics.errors.push(entry);
    }
}

class PopupManager {
    constructor() {
        // Add monitoring system
        this.monitor = new MonitoringSystem();
        
        console.log('Constructing PopupManager'); // Changed log message
        
        // Initialize managers with monitoring
        // TODO: Ensure these helper classes are defined and loaded globally or imported
        // this.tableManager = new TableManager();
        // this.loadingManager = new LoadingManager();
        // this.errorManager = new ErrorManager();
        // For now, use basic placeholders if classes aren't defined/loaded
        this.tableManager = { initialize: () => console.log('TableManager placeholder init') };
        this.loadingManager = { showLoading: (msg) => console.log('Loading:', msg), hideLoading: () => console.log('Hide Loading') };
        this.errorManager = { showError: (msg) => alert(`Error: ${msg}`), showSuccess: (msg) => alert(`Success: ${msg}`) };

        this.gmcApi = new GMCApi(); // Instantiate GMCApi
        this.gmcValidator = new GMCValidator(this.gmcApi);
        // TODO: Ensure FeedAnalyzer is defined/loaded
        // this.feedAnalyzer = new FeedAnalyzer(this.tableManager);
        this.feedAnalyzer = { analyzeFeed: (data) => { console.log('FeedAnalyzer placeholder analyze'); return { issues: [], totalProducts: data.length }; } };

        // Initialize validation results storage
        this.validationResults = {};
        this.activeValidationPanel = null; // Track the floating panel

        // --- Get UI element references ---
        // FeedManager elements
        const fileInputEl = document.getElementById('fileInput');
        const previewButtonEl = document.getElementById('previewFeed');
        this.previewContentContainer = document.getElementById('previewContent'); // Needed by SearchManager too
        // Other elements
        this.exportButton = document.getElementById('exportFeed');
        this.verifyGMCButton = document.getElementById('verifyGMCConnection');
        this.validateGMCButton = document.getElementById('validateGMC');
        this.logoutButton = document.getElementById('logoutButton');
        this.mainDropdown = document.getElementById('analysisDropdown');
        // Search elements
        const searchInputEl = document.getElementById('searchInput');
        const searchColumnSelectEl = document.getElementById('searchColumn');
        const searchTypeSelectEl = document.getElementById('searchType');
        const clearSearchBtnEl = document.getElementById('clearSearchBtn');
        const searchStatusEl = document.querySelector('.search-status');

        // --- Instantiate Managers ---
        this.statusBarManager = new StatusBarManager(
            this.gmcApi,
            this.verifyGMCButton,
            this.validateGMCButton,
            this.logoutButton
        );

        this.searchManager = new SearchManager({
            searchInput: searchInputEl,
            searchColumnSelect: searchColumnSelectEl,
            searchTypeSelect: searchTypeSelectEl,
            clearSearchBtn: clearSearchBtnEl,
            tableContainer: this.previewContentContainer,
            statusElement: searchStatusEl
        });

        this.feedManager = new FeedManager(
            { // Elements for FeedManager
                fileInput: fileInputEl,
                previewButton: previewButtonEl,
                previewContentContainer: this.previewContentContainer
            },
            { // Managers needed by FeedManager
                loadingManager: this.loadingManager,
                errorManager: this.errorManager,
                searchManager: this.searchManager, // Pass SearchManager for updating columns
                monitor: this.monitor
            }
        );

        // Defer setup until after async initialization
        // this.setupEventListeners();
        // this.setupScrollSync();
        // this.setupTabs();
        // this.initializeSearch();

        // Start async initialization
        this.initializePopup();
    }

    /**
     * Asynchronously initializes the popup, including API and UI setup.
     */
    async initializePopup() {
        console.log('Initializing Popup asynchronously...');
        this.loadingManager.showLoading('Initializing...');
        try {
            // Initialize GMCApi to load stored credentials
            await this.gmcApi.initialize();
            console.log('GMCApi initialized. Authenticated:', this.gmcApi.isAuthenticated);

            // Setup UI elements that might depend on auth state
            this.setupElements();
            // StatusBarManager constructor already called setupStatusBar()
            this.statusBarManager.updateUI(); // Update status bar content based on auth state

            // Setup remaining UI components and listeners
            this.tableManager.initialize();
            this.setupScrollSync();
            this.setupTabs();
            this.initializeSearch();
            this.setupEventListeners(); // Setup listeners after elements are ready

            this.loadingManager.hideLoading();
            console.log('Popup initialization complete.');

        } catch (error) {
            console.error('Popup initialization failed:', error);
            this.errorManager.showError(`Initialization failed: ${error.message}`);
            this.loadingManager.hideLoading();
            // Update status bar to show error state?
            this.updateStatusBarUI(true); // Pass error flag
        }
    }

    // Removed old initialize() method

    setupElements() {
        console.log('Setting up elements');
        
        this.dataContainer = document.querySelector('.data-container');

        if (!this.fileInput) console.error('File input not found');
        if (!this.previewButton) console.error('Preview button not found');
        if (!this.exportButton) console.error('Export button not found');
        if (!this.mainDropdown) console.error('Analysis dropdown not found');
        if (!this.dataContainer) console.error('Data container not found');
    }

    setupEventListeners() {
        console.log('Setting up event listeners');

        // File Input & Preview Button listeners removed - handled by FeedManager

        // Export Button
        if (this.exportButton) {
            this.exportButton.addEventListener('click', () => this.handleExport());
        }

        // Analysis Dropdown (if exists)
        if (this.mainDropdown) {
            this.mainDropdown.addEventListener('change', (e) => this.handleDropdownChange(e));
        }

        // Verify GMC Connection Button
        if (this.verifyGMCButton) {
            // Rename handler to reflect new logic
            this.verifyGMCButton.addEventListener('click', () => this.verifyOrAuthenticateGMC());
        } else {
            console.warn('Verify GMC button not found.');
        }

        // Validate Feed Button
        if (this.validateGMCButton) {
            this.validateGMCButton.addEventListener('click', () => this.validateWithGMC());
        } else {
            console.warn('Validate GMC button not found.');
        }

        // Logout Button
        if (this.logoutButton) {
            this.logoutButton.addEventListener('click', () => this.handleLogout());
        } else {
            console.warn('Logout button not found in the DOM.');
        }
    }
    // Removed duplicated listener blocks that were here

    // handlePreview method removed - logic moved to FeedManager

    async readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                // First try to detect the encoding
                const buffer = e.target.result;
                const decoder = new TextDecoder('utf-8', { fatal: true });
                
                try {
                    const text = decoder.decode(buffer);
                    resolve(text);
                } catch (encodingError) {
                    // If UTF-8 fails, try another common encoding
                    try {
                        const fallbackDecoder = new TextDecoder('iso-8859-1');
                        const text = fallbackDecoder.decode(buffer);
                        resolve(text);
                    } catch (fallbackError) {
                        reject(new Error('Unable to decode file content'));
                    }
                }
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    parseCSV(csvText) {
        // Normalize encoding first
        const normalized = csvText.normalize('NFKD')
            .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
            .replace(/[^\x00-\x7F]/g, '');   // Remove non-ASCII

        const lines = normalized.split('\n').filter(line => line.trim());
        
        // Get headers
        const headers = lines[0].split(',').map(h => h.trim());
        
        // Parse data rows
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;
            
            // Split the line by comma, handling quoted values
            const values = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
            
            // Create object from headers and values
                const row = {};
                headers.forEach((header, index) => {
                let value = values[index] || '';
                // Clean the value
                value = value
                    .replace(/^"|"$/g, '')  // Remove quotes
                    .trim();
                row[header] = value;
                });
                data.push(row);
        }
        
        return data;
    }

    async displayPreview(data) {
        const container = document.getElementById('previewContent');
        if (!container) return;

        const table = document.createElement('table');
        table.className = 'preview-table';

        // Get all unique headers from the data
        const headers = Object.keys(data[0] || {});
        
        // Create header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        headers.forEach(key => {
            const th = document.createElement('th');
            th.textContent = key;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Create body
        const tbody = document.createElement('tbody');
        data.forEach((row, index) => {
            const tr = document.createElement('tr');
            tr.id = `row-${index + 1}`;
            
            headers.forEach(key => {
                if (key === 'title' || key === 'description') {
                    tr.appendChild(this.createEditableCell(row[key] || '', key, index));
                } else {
                    const td = document.createElement('td');
                    td.textContent = row[key] || '';
                    tr.appendChild(td);
                }
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);

        container.innerHTML = ''; // Clear previous content
        container.appendChild(table);

        // Update search columns now that the table with headers exists
        if (this.searchManager) {
            this.searchManager.updateSearchColumns();
        }
    }

    handleDropdownChange(e) {
        const selectedValue = e.target.value;
        
        if (selectedValue === 'analyze-feed') {
                this.analyzeFeed();
        }
    }

    analyzeFeed() {
        const table = document.querySelector('.preview-table');
        if (!table) {
            alert('Please load and preview a feed first before analyzing.');
            return;
        }

        try {
            // Get headers from the table
            const headers = Array.from(table.querySelectorAll('thead th'))
                .map(th => th.textContent.trim().toLowerCase());

            // Get all rows except header
            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const totalProducts = rows.length;
            
            // Initialize analysis object
            const analysis = {
                totalProducts,
                titleErrors: 0,      // < 25 chars
                titleWarnings: 0,    // 25-70 chars
                titleOptimal: 0,     // 70-150 chars
                titleTooLong: 0,     // > 150 chars
                titleIssues: 0,
                descriptionIssues: 0,
                missingImages: 0,
                invalidPrices: 0,
                categories: new Set(),
                titleLengthStats: {
                    underMinimum: 0,    // < 25
                    underOptimal: 0,    // 25-70
                    optimal: 0,         // 70-150
                    tooLong: 0          // > 150
                },
                titleLengths: [],
                descriptionLengths: [],
                duplicateTitles: new Map(),
                duplicateDescriptions: new Map(),
                allCapsCount: 0
            };

            // Find column indexes
            const titleIndex = headers.indexOf('title');
            const descriptionIndex = headers.indexOf('description');
            const imageUrlIndex = headers.indexOf('image_link');
            const priceIndex = headers.indexOf('price');
            const categoryIndex = headers.indexOf('google_product_category');

            // Analyze each row
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                
                const titleField = cells[titleIndex]?.querySelector('.editable-field')?.textContent.trim() || '';
                const descriptionField = cells[descriptionIndex]?.querySelector('.editable-field')?.textContent.trim() || '';
                const imageUrl = cells[imageUrlIndex]?.textContent.trim() || '';
                const price = cells[priceIndex]?.textContent.trim() || '';
                const category = cells[categoryIndex]?.textContent.trim() || '';

                // Updated title validation logic
                if (titleField.length < 25) {
                    analysis.titleErrors++;
                    analysis.titleLengthStats.underMinimum++;
                    analysis.titleIssues++;
                } else if (titleField.length < 70) {
                    analysis.titleWarnings++;
                    analysis.titleLengthStats.underOptimal++;
                } else if (titleField.length <= 150) {
                    analysis.titleOptimal++;
                    analysis.titleLengthStats.optimal++;
                } else {
                    analysis.titleTooLong++;
                    analysis.titleLengthStats.tooLong++;
                    analysis.titleIssues++;
                }

                // Keep existing description validation
                if (descriptionField.length < 150) {
                    analysis.descriptionIssues++;
                    analysis.descTooShort++;
                }
                if (descriptionField.length > 5000) {
                    analysis.descriptionIssues++;
                    analysis.descTooLong++;
                }

                // Track duplicates
                analysis.duplicateTitles.set(titleField, (analysis.duplicateTitles.get(titleField) || 0) + 1);
                analysis.duplicateDescriptions.set(descriptionField, (analysis.duplicateDescriptions.get(descriptionField) || 0) + 1);

                // Track categories
                if (category) {
                    category.split('>').forEach(cat => {
                        const trimmedCat = cat.trim();
                        if (trimmedCat) {
                            analysis.categories.add(trimmedCat);
                        }
                    });
                }

                // Check image URL
                if (!imageUrl.startsWith('https://')) {
                    analysis.missingImages++;
                }

                // Check price format
                if (price) {
                    const parts = price.trim().split(' ');
                    if (parts.length !== 2 || isNaN(parseFloat(parts[0])) || parts[1] !== 'USD') {
                        analysis.invalidPrices++;
                    }
                }

                // Track title length
                analysis.titleLengths.push(titleField.length);
                analysis.descriptionLengths.push(descriptionField.length);
            });

            this.displayAnalysisReport(analysis, rows);

        } catch (error) {
            console.error('Error analyzing feed:', error);
            alert('Error analyzing feed. Please try again.');
        }
    }

    displayAnalysisReport(analysis, rows) {
        const healthScore = Math.round((1 - (analysis.titleIssues + analysis.descriptionIssues)/(analysis.totalProducts * 2)) * 100);
        
        // Determine health score color
        let healthColor = '#27ae60'; // Green
        if (healthScore < 70) healthColor = '#e67e22'; // Orange
        if (healthScore < 50) healthColor = '#e74c3c'; // Red

        const analysisHtml = `
            <div class="analysis-report">
                <div class="report-header">
                    <h3>Feed Health Analysis</h3>
                    <button class="close-analysis" title="Close Analysis">×</button>
                </div>
                
                <div class="health-score">
                    <h4>Overall Feed Health</h4>
                    <div class="progress-bar">
                        <div class="progress" style="width: ${healthScore}%; background: ${healthColor}"></div>
                    </div>
                    <div class="score-text" style="color: ${healthColor}">${healthScore}% Healthy</div>
                </div>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <h4>Overall Stats</h4>
                        <p><strong>Total Products:</strong> ${analysis.totalProducts}</p>
                        <p><strong>Categories:</strong> ${analysis.categories.size}</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Content Health</h4>
                        <p>
                            <strong>Title Issues:</strong> 
                            <span class="validation-badge ${analysis.titleIssues > 0 ? 'error' : 'success'}">
                                ${analysis.titleIssues} (${Math.round(analysis.titleIssues/analysis.totalProducts*100)}%)
                            </span>
                        </p>
                        <p>
                            <strong>Description Issues:</strong> 
                            <span class="validation-badge ${analysis.descriptionIssues > 0 ? 'error' : 'success'}">
                                ${analysis.descriptionIssues} (${Math.round(analysis.descriptionIssues/analysis.totalProducts*100)}%)
                            </span>
                        </p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Technical Issues</h4>
                        <p>
                            <strong>Image Issues:</strong> 
                            <span class="validation-badge ${analysis.missingImages > 0 ? 'error' : 'success'}">
                                ${analysis.missingImages}
                            </span>
                        </p>
                        <p>
                            <strong>Price Issues:</strong> 
                            <span class="validation-badge ${analysis.invalidPrices > 0 ? 'error' : 'success'}">
                                ${analysis.invalidPrices}
                            </span>
                        </p>
                    </div>
                </div>

                ${this.generateIssuesList(rows)}
            </div>
        `;

        // Remove any existing analysis report
            const existingReport = document.querySelector('.analysis-report');
            if (existingReport) {
                existingReport.remove();
            }

        // Insert the analysis report before the data table
        const dataContainer = document.querySelector('.data-container');
        const analysisElement = document.createElement('div');
        analysisElement.innerHTML = analysisHtml;
        dataContainer.insertBefore(analysisElement, dataContainer.firstChild);

        this.setupAnalysisInteractivity();
    }

    generateIssuesList(rows) {
        const issues = [];
        
        rows.forEach((row, index) => {
            const titleField = row.querySelector('.title-field')?.textContent.trim() || '';
            const descriptionField = row.querySelector('.description-field')?.textContent.trim() || '';
            const rowIssues = [];

            // Only show critical issues
            if (titleField.length < 25) {
                rowIssues.push(`Title too short (${titleField.length} chars). Minimum 25 characters required for Google Shopping.`);
            }
            if (descriptionField.length < 70) {
                rowIssues.push(`Description too short (${descriptionField.length} chars). Minimum 70 characters required for Google Shopping.`);
            }

            if (rowIssues.length > 0) {
                issues.push(`
                    <div class="issue-item">
                        <strong class="row-link" data-row-id="row-${index + 1}">Row ${index + 1}</strong>
                        ${rowIssues.map(issue => `
                            <div class="issue-message" data-row-id="row-${index + 1}">- ${issue}</div>
                        `).join('')}
                    </div>
                `);
            }
        });

        return issues.length > 0 ? `
            <div class="issues-list">
                <h4>Critical Issues</h4>
                ${issues.join('')}
            </div>
        ` : '<div class="no-issues">No issues found! Your feed meets Google Shopping requirements.</div>';
    }

    setupAnalysisInteractivity() {
        // Add click handlers for row links
        document.querySelectorAll('.row-link, .issue-message').forEach(element => {
            element.addEventListener('click', (e) => {
                const rowId = e.target.getAttribute('data-row-id');
                this.scrollToTableRow(rowId);
            });
        });

        // Add close button handler
        const closeButton = document.querySelector('.close-analysis');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                const report = document.querySelector('.analysis-report');
                if (report) report.remove();
            });
        }
    }

    scrollToTableRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) {
            // Smooth scroll to row
            row.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center'
            });
            
            // Add highlight effect
            row.style.transition = 'background-color 0.3s ease-in-out';
            row.style.backgroundColor = '#fff3cd';
            
            setTimeout(() => {
                row.style.backgroundColor = '';
                // Clean up after animation
                setTimeout(() => {
                    row.style.transition = '';
                }, 300);
            }, 1500);
        }
    }

    async handleExport() {
        try {
            const table = document.querySelector('.data-table');
            if (!table) {
                this.errorManager.showError('Please load and preview a feed first before exporting.');
                return;
            }

            const feedData = this.getFeedDataFromTable(table);
            if (!feedData || !feedData.length) {
                this.errorManager.showError('No data to export');
                return;
            }

            // Convert to CSV
            const headers = Object.keys(feedData[0]);
            const csv = [
                headers.join(','),
                ...feedData.map(row => headers.map(header => {
                    const value = row[header] || '';
                    return value.includes(',') ? `"${value}"` : value;
                }).join(','))
            ].join('\n');

            // Create download link
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'exported_feed.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            this.errorManager.showError('Feed exported successfully!', 3000);
        } catch (error) {
            console.error('Export failed:', error);
            this.errorManager.showError('Failed to export feed');
        }
    }

    getFeedDataFromTable(table) {
        const headerCells = Array.from(table.querySelectorAll('tr:first-child th'));
        const headerMap = new Map();
        
        headerCells.forEach((th, index) => {
            const headerName = th.textContent.trim().toLowerCase();
            if (headerName && headerName !== '#') {
                headerMap.set(headerName, index);
            }
        });

        const rows = Array.from(table.querySelectorAll('tr:not(.table-header)'));
        
        return rows.map(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            const rowData = {};
            
            headerMap.forEach((columnIndex, headerName) => {
                const cell = cells[columnIndex];
                if (cell) {
                    const editableField = cell.querySelector('.editable-field');
                    const value = editableField ? 
                        editableField.textContent.trim() : 
                        cell.textContent.trim();
                    
                    if (value) {
                        rowData[headerName] = value;
                    }
                }
            });
            
            return rowData;
        }).filter(row => Object.keys(row).length > 0);
    }

    /**
     * Verifies GMC connection status or initiates authentication if needed.
     */
    async verifyOrAuthenticateGMC() {
        this.loadingManager.showLoading('Checking GMC Connection...');
        try {
            let message = '';
            if (this.gmcApi.isAuthenticated) {
                // Optional: Could make a quick test call like fetchMerchantInfo again
                // to ensure the token is still valid, but chrome.identity handles refresh.
                console.log('Already authenticated. Merchant ID:', this.gmcApi.merchantId);
                message = `Already connected to GMC (Merchant ID: ${this.gmcApi.merchantId})`;
                this.errorManager.showSuccess(message, 3000);
            } else {
                console.log('Not authenticated, attempting to authenticate...');
                const success = await this.gmcApi.authenticate();
                if (success) {
                    message = `Successfully connected to GMC (Merchant ID: ${this.gmcApi.merchantId})`;
                    this.errorManager.showSuccess(message, 3000);
                    this.updateStatusBarUI(); // Update UI after successful auth
                } else {
                    // Should not be reached if authenticate throws on error
                    message = 'Authentication failed. Please try again.';
                    this.errorManager.showError(message);
                }
            }
        } catch (error) {
            console.error('GMC connection/authentication failed:', error);
            let errorMessage = 'Could not connect to GMC.';
            if (error.message && error.message.includes('No merchant account found')) {
                errorMessage = 'Connection failed: No Google Merchant Center account found or accessible.';
            } else if (error.message) {
                errorMessage = `Connection failed: ${error.message}`;
            }
            this.errorManager.showError(errorMessage);
            this.updateStatusBarUI(true); // Update UI to reflect error state
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    /**
     * Handles the logout process.
     */
    async handleLogout() {
        console.log('Logout button clicked');
        this.loadingManager.showLoading('Logging out...');
        try {
            await this.gmcApi.logout();
            this.errorManager.showSuccess('Successfully logged out.', 2000);
            this.updateStatusBarUI(); // Update UI to logged-out state
            // Optional: Disable buttons that require auth?
            // Optional: Redirect to login.html?
            // window.location.href = 'login.html'; // This would navigate the current tab
        } catch (error) {
            console.error('Logout failed:', error);
            this.errorManager.showError(`Logout failed: ${error.message}`);
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    /**
     * Updates the status bar UI based on authentication state.
     * @param {boolean} [isError=false] - Flag to indicate an error state.
     */
    updateStatusBarUI(isError = false) {
        if (!this.statusBar) {
            console.warn('Status bar element not found, cannot update UI.');
            return;
        }

        const { merchantInfo, modeIndicator } = this.statusBar;
        const merchantValueEl = merchantInfo.querySelector('.merchant-value');
        const statusDotEl = modeIndicator.querySelector('.status-dot');
        const statusTextEl = modeIndicator.querySelector('.status-text');

        if (isError) {
            merchantValueEl.textContent = 'Error';
            merchantValueEl.style.color = '#dc3545'; // Red
            statusDotEl.className = 'status-dot error';
            statusTextEl.textContent = 'Connection Error';
        } else if (this.gmcApi.isAuthenticated && this.gmcApi.merchantId) {
            merchantValueEl.textContent = this.gmcApi.merchantId;
            merchantValueEl.style.color = ''; // Reset color
            statusDotEl.className = 'status-dot live'; // Assume live if authenticated
            statusTextEl.textContent = 'Connected';
            // Enable buttons requiring auth?
            if(this.validateGMCButton) this.validateGMCButton.disabled = false;
            if(this.logoutButton) this.logoutButton.style.display = ''; // Show logout
            if(this.verifyGMCButton) this.verifyGMCButton.textContent = 'GMC Connected'; // Change text

        } else {
            merchantValueEl.textContent = 'Not Connected';
            merchantValueEl.style.color = '#ffc107'; // Yellow/Orange
            statusDotEl.className = 'status-dot disconnected';
            statusTextEl.textContent = 'Disconnected';
            // Disable buttons requiring auth?
            if(this.validateGMCButton) this.validateGMCButton.disabled = true;
            if(this.logoutButton) this.logoutButton.style.display = 'none'; // Hide logout
            if(this.verifyGMCButton) this.verifyGMCButton.textContent = 'Verify GMC Connection'; // Reset text
        }
    }

    // --- Existing methods continue below ---

    showValidationProgress() {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        
        const progress = document.createElement('div');
        progress.className = 'validation-progress';
        progress.innerHTML = `
            <h3>Validating Feed</h3>
            <div class="progress-bar"></div>
            <div class="progress-text">Processing...</div>
        `;
        
        document.body.appendChild(overlay);
        document.body.appendChild(progress);
        return { overlay, progress };
    }

    async validateWithGMC() {
        this.loadingManager.showLoading('Validating feed with Google Merchant Center...');
        try {
            this.monitor.logOperation('gmc_validation', 'started');

            // Ensure authenticated
            if (!this.gmcApi.isAuthenticated) {
                await this.verifyOrAuthenticateGMC(); // Attempt auth if needed
                if (!this.gmcApi.isAuthenticated) {
                    throw new Error('Authentication required to validate with GMC.');
                }
            }

            // Switch to validation tab first (optional, could display results elsewhere)
            const validationTab = document.querySelector('.tab-button[data-tab="validation"]');
            const validationPanel = document.getElementById('validation-tab');
            if (validationTab && validationPanel) {
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
                validationTab.classList.add('active');
                validationPanel.classList.add('active');
            }

            // Generate feedId
            const feedId = `GMC-VAL-${Date.now().toString().slice(-6)}`;

            // Get feed data
            const feedData = this.getCurrentFeedData();
            if (!feedData?.length) {
                this.errorManager.showError('No feed data available to validate.');
                this.monitor.logOperation('gmc_validation', 'failed', { reason: 'no_data' });
                return;
            }

            // Run ONLY GMC API validation
            console.log(`Calling gmcValidator.validate for ${feedData.length} items...`);
            const gmcResults = await this.gmcValidator.validate(feedData);
            console.log('GMC Validation Results:', gmcResults);

            // Store results (using the format returned by the API/validator)
            // Format: { isValid, totalProducts, validProducts, issues: [{ rowIndex, field, type, message }] }
            this.validationResults[feedId] = gmcResults;

            // Update validation history - this will show in the validation tab
            this.updateValidationHistory(feedId, gmcResults);

            // Optionally display results immediately in the floating panel
            this.handleViewDetails(feedId, gmcResults);

            this.monitor.logOperation('gmc_validation', 'completed', { issues: gmcResults.issues?.length || 0 });
            this.errorManager.showSuccess('GMC validation complete.', 3000);

        } catch (error) {
            this.monitor.logError(error, 'validateWithGMC');
            console.error('GMC Validation failed:', error);
            this.errorManager.showError(`GMC Validation failed: ${error.message}`);
            this.monitor.logOperation('gmc_validation', 'failed', { error: error.message });
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    showValidationResults(results) {
        // Add overlay
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        document.body.appendChild(overlay);

        const resultsEl = document.createElement('div');
        resultsEl.className = 'validation-results';
        resultsEl.innerHTML = `
            <div class="results-header">
                <h3>Validation Results</h3>
                <button class="close-results">×</button>
            </div>
            <div class="results-content">
                <div class="results-summary">
                    <div class="summary-item">
                        <span class="label">Total Products:</span>
                        <span class="value">${results.totalProducts}</span>
                    </div>
                    <div class="summary-item">
                        <span class="label">Valid Products:</span>
                        <span class="value">${results.validProducts}</span>
                    </div>
                    <div class="summary-item">
                        <span class="label">Issues Found:</span>
                        <span class="value">${results.issues.length}</span>
                    </div>
                </div>
                ${this.formatValidationIssues(results.issues)}
            </div>
        `;

        document.body.appendChild(resultsEl);

        // Add close handler
        resultsEl.querySelector('.close-results').addEventListener('click', () => {
            overlay.remove();
            resultsEl.remove();
        });

        // Close on overlay click
        overlay.addEventListener('click', () => {
            overlay.remove();
            resultsEl.remove();
        });
    }

    formatValidationIssues(issues) {
        if (!issues || !issues.length) return '<p class="no-issues">No issues found according to Google Merchant Center!</p>';

        // Group issues by row index for better display
        const issuesByRow = issues.reduce((acc, issue) => {
            const rowIndex = issue.rowIndex || 'unknown'; // Handle potential missing rowIndex
            if (!acc[rowIndex]) {
                acc[rowIndex] = [];
            }
            acc[rowIndex].push(issue);
            return acc;
        }, {});

        return `
            <div class="issues-list gmc-issues">
                <h4>GMC Validation Issues</h4>
                ${Object.entries(issuesByRow).map(([rowIndex, rowIssues]) => `
                    <div class="issue-group">
                        <div class="issue-group-header">
                            <strong>Row ${rowIndex}</strong>
                            ${rowIndex !== 'unknown' ? `<a href="#" class="row-link" data-row="${rowIndex}" title="Scroll to row ${rowIndex}">Go to Row</a>` : ''}
                        </div>
                        ${rowIssues.map(issue => `
                            <div class="issue-item ${issue.type || 'error'}">
                                <span class="issue-severity">${issue.type || 'error'}</span>
                                <span class="issue-message">${issue.message || 'Unknown issue'}</span>
                                ${issue.field && issue.field !== 'general' ? `<span class="issue-field">(Field: ${issue.field})</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `).join('')}
            </div>
        `;
    }

    checkErrors() {
        this.errorManager.showError('Error checking is a PRO feature. Please upgrade to access this functionality.');
    }

    viewSummary() {
        this.errorManager.showError('Feed summary is a PRO feature. Please upgrade to access this functionality.');
    }

    // Add debounce helper
    debounce(func, wait) {
        clearTimeout(this.debounceTimeout);
        this.debounceTimeout = setTimeout(func, wait);
    }

    // Add text sanitization helper
    sanitizeText(text) {
        return text
            // First normalize the text to handle composite characters
            .normalize('NFKD')
            // Replace common problematic characters
            .replace(/[\u2022]/g, '•')           // Proper bullet point
            .replace(/[\u2013\u2014]/g, '-')     // En and Em dashes
            .replace(/[\u201C\u201D]/g, '"')     // Smart quotes
            .replace(/[\u2018\u2019]/g, "'")     // Smart single quotes
            // Then clean up any remaining issues
            .replace(/â€¢/g, '•')                // Fix broken bullet points
            .replace(/â€œ|â€/g, '"')            // Fix broken quotes
            .replace(/â€™/g, "'")                // Fix broken apostrophes
            .replace(/\s+/g, ' ')                // Normalize spaces
            .trim();
    }

    createEditableCell(content, type, rowIndex) {
        const cell = document.createElement('td');
        const field = document.createElement('div');
        field.className = `editable-field ${type}-field`;
        field.contentEditable = true;
        field.dataset.field = type;
        field.textContent = this.sanitizeText(content);

        // Add character count display
        const charCountDisplay = document.createElement('div');
        charCountDisplay.className = 'char-count';
        
        // Update maxLength - show 70 for titles
        const maxLength = type === 'description' ? 90 : 70;  // Changed from 150 to 70 for titles
        
        cell.appendChild(field);
        cell.appendChild(charCountDisplay);
        
        // Now initialize character count after elements are connected
        const currentLength = field.textContent.length;
        charCountDisplay.textContent = `${currentLength}/${maxLength}`;
        
        // Set initial color - simplified logic
        if (type === 'description') {
            charCountDisplay.style.color = currentLength >= 90 ? '#28a745' : '#dc3545';
        } else {
            charCountDisplay.style.color = currentLength >= 25 ? '#28a745' : '#dc3545';
        }

        // Update count on input
        field.addEventListener('input', () => {
            const currentContent = field.textContent;
            const currentCount = currentContent.length;
            charCountDisplay.textContent = `${currentCount}/${maxLength}`;
            
            // Simplified color logic
            if (type === 'description') {
                charCountDisplay.style.color = currentCount >= 90 ? '#28a745' : '#dc3545';
            } else {
                charCountDisplay.style.color = currentCount >= 25 ? '#28a745' : '#dc3545';
            }
            
            this.debounce(() => this.analyzeFeed(), 500);
        });

        return cell;
    }

    setupScrollSync() {
        const dataContainer = document.querySelector('.data-container');
        const scrollThumb = document.querySelector('.scroll-thumb');
        const scrollTrack = document.querySelector('.scroll-track');
        
        if (!dataContainer || !scrollThumb || !scrollTrack) return;

        // Calculate scrollbar width once
        const scrollbarWidth = dataContainer.offsetWidth - dataContainer.clientWidth;

        // Update thumb width accounting for scrollbar
        const updateThumbWidth = () => {
            // Use offsetWidth to include scrollbar in calculation
            const containerWidth = dataContainer.offsetWidth - scrollbarWidth;
            const scrollRatio = containerWidth / dataContainer.scrollWidth;
            const thumbWidth = Math.max(scrollRatio * 100, 10); // Minimum 10% width
            scrollThumb.style.width = `${thumbWidth}%`;
        };

        // Initial setup
        updateThumbWidth();

        // Sync floating scroll with content
        dataContainer.addEventListener('scroll', () => {
            const maxScroll = dataContainer.scrollWidth - dataContainer.offsetWidth + scrollbarWidth;
            const scrollRatio = dataContainer.scrollLeft / maxScroll;
            const trackWidth = scrollTrack.clientWidth - scrollThumb.offsetWidth;
            const thumbPosition = scrollRatio * trackWidth;
            scrollThumb.style.transform = `translateX(${thumbPosition}px)`;
        });

        // Handle thumb drag
        let isDragging = false;
        let startX;
        let scrollLeft;

        scrollThumb.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.pageX - scrollThumb.offsetLeft;
            scrollLeft = dataContainer.scrollLeft;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            e.preventDefault();
            const x = e.pageX - scrollTrack.getBoundingClientRect().left;
            const walk = (x - startX) * (dataContainer.scrollWidth / scrollTrack.clientWidth);
            dataContainer.scrollLeft = scrollLeft + walk;
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Handle window resize
        window.addEventListener('resize', updateThumbWidth);
    }

    // setupStatusBar() method removed - logic moved to StatusBarManager

    updateStatus(action, success = true) {
        if (!this.statusBar) return;
        
        const { lastAction } = this.statusBar;
        lastAction.innerHTML = `
            <span class="action-text ${success ? 'success' : 'error'}">${action}</span>
        `;
        
        // Auto-clear after 3 seconds
        setTimeout(() => {
            lastAction.innerHTML = '<span class="action-text">Ready</span>';
        }, 3000);
    }

    setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabPanels = document.querySelectorAll('.tab-panel');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                console.log('Tab clicked:', button.dataset.tab);
                
                // Remove active class from all buttons and panels
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanels.forEach(panel => panel.classList.remove('active'));

                // Add active class to clicked button and corresponding panel
                button.classList.add('active');
                const panelId = `${button.dataset.tab}-tab`;
                console.log('Activating panel:', panelId);
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.classList.add('active');
                }
            });
        });
    }

    handleViewDetails(feedId, validationData) {
        // Switch to feed preview tab first
        const feedTab = document.querySelector('.tab-button[data-tab="feed"]');
        if (feedTab) {
            feedTab.click();
        }
        
        // Create validation panel
        const panel = this.createValidationPanel(feedId, validationData);
        
        // Add row navigation without triggering analysis
        this.setupRowNavigation(panel);
        
        // Make sure panel is visible
        panel.style.display = 'block';
        panel.style.opacity = '1';
    }

    showFeedPreview() {
        // Stop any ongoing analysis
        this.feedAnalyzer.stopAnalysis();
        
        // Show feed preview tab
        const feedTab = document.querySelector('.tab-button[data-tab="feed"]');
        if (feedTab && !feedTab.classList.contains('active')) {
            feedTab.click();
        }
    }

    setupRowNavigation(panel) {
        panel.querySelectorAll('.row-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const rowIndex = parseInt(link.dataset.row);
                
                // Navigate without analysis
                this.navigateToRow(rowIndex, link.closest('.issue-item').dataset.field);
            });
        });
    }

    navigateToRow(rowIndex, fieldToFix) {
        // Ensure we're in feed preview mode first
        this.showFeedPreview();

        // Small delay to ensure tab switch is complete
        setTimeout(() => {
            const targetRow = document.querySelector(`#previewContent tbody tr:nth-child(${rowIndex})`);
            if (!targetRow) return;

            // First remove any existing highlights
            targetRow.classList.remove('fix-complete');
            
            // Add highlight with transition
            targetRow.classList.add('needs-fix');
            targetRow.classList.add('row-highlight');
            
            // Scroll into view
            targetRow.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });

            // Setup field monitoring
            this.monitorFieldChanges(targetRow, fieldToFix);
        }, 100);
    }

    monitorFieldChanges(row, fieldToFix) {
        const field = row.querySelector(`[data-field="${fieldToFix}"]`);
        if (!field) return;

        const checkAndRemoveHighlight = () => {
            const content = field.textContent;
            const minRequired = fieldToFix === 'description' ? 90 : 25;
            
            if (content.length >= minRequired) {
                // Remove the initial highlight class
                row.classList.remove('needs-fix');
                row.classList.remove('row-highlight');
                
                // Add the completion highlight
                row.classList.add('fix-complete');
                
                // Get the row index and update the validation panel
                const rowIndex = parseInt(row.getAttribute('data-row')) || 
                                Array.from(row.parentElement.children).indexOf(row) + 1;
                const feedId = this.activeValidationPanel?.dataset.feedId;
                if (feedId) {
                    // Store the validation state before updating
                    const validationData = this.validationResults[feedId];
                    if (validationData) {
                        // Remove the fixed issue from the validation data
                        validationData.issues = validationData.issues.filter(issue => 
                            !(issue.field === fieldToFix && issue.affectedProducts[0] === rowIndex)
                        );
                    }
                    this.updateValidationPanelIssues(feedId, fieldToFix, rowIndex);
                }

                // Remove the completion highlight after animation
                setTimeout(() => {
                    row.classList.remove('fix-complete');
                }, 1000);
                
                field.removeEventListener('input', checkAndRemoveHighlight);
            }
        };

        field.addEventListener('input', checkAndRemoveHighlight);
    }

    handleFieldEdit(field) {
        // Get row and field info
        const row = field.closest('tr');
        const rowIndex = row.dataset.row;
        const fieldName = field.dataset.field;
        const newValue = field.textContent;

        // Validate the field
        const isValid = this.validateFieldContent(fieldName, newValue);
        
        // If field is now valid, remove the validation highlight
        if (isValid) {
            row.classList.remove('validation-focus');
            
            // Update validation panel if it exists
            if (this.activeValidationPanel) {
                this.updateValidationPanelIssues(rowIndex, fieldName);
            }
        }

        // Update character count
        if (fieldName === 'title' || fieldName === 'description') {
            window.updateCharCount(field, fieldName === 'title' ? 150 : 5000);
        }
    }

    validateFieldContent(fieldName, content) {
        if (fieldName === 'title') {
            return content.length >= 25 && content.length <= 150;
        } else if (fieldName === 'description') {
            return content.length >= 90 && content.length <= 5000;
        }
        return true;
    }

    createValidationDetails(data) {
        if (!data || !data.issues) {
            console.error('Invalid validation data:', data);
            return;
        }

        const detailsRow = document.createElement('tr');
        detailsRow.className = 'validation-details-row';
        
        const detailsCell = document.createElement('td');
        detailsCell.colSpan = 5;
        
        if (data.isValid) {
            detailsCell.innerHTML = `
                <div class="validation-details success">
                    <h4>Validation Successful</h4>
                    <div class="details-content">
                        <p>✅ All products meet GMC requirements</p>
                        <p>Total Products Validated: ${data.totalProducts}</p>
                        <button class="modern-button">Re-validate Feed</button>
                    </div>
                </div>
            `;
        } else {
            // Ensure we create issuesByRow
            const issuesByRow = this.groupIssuesByRow(data.issues || []);
            
            detailsCell.innerHTML = `
                <div class="validation-details error">
                    <h4>Validation Issues Found</h4>
                    <div class="details-content">
                        <div class="quick-filters">
                            <button class="filter-btn active" data-filter="all">
                                All Issues (${data.issues.length})
                            </button>
                            <button class="filter-btn" data-filter="title-only">
                                Title Only (${this.countIssuesByType(data.issues, 'title', true)})
                            </button>
                            <button class="filter-btn" data-filter="description-only">
                                Description Only (${this.countIssuesByType(data.issues, 'description', true)})
                            </button>
                            <button class="filter-btn" data-filter="both">
                                Both Issues (${this.countRowsWithBothIssues(issuesByRow)})
                            </button>
                        </div>
                        <div class="issues-list">
                            ${this.formatIssuesList(data.issues, issuesByRow)}
                        </div>
                    </div>
                </div>
            `;
        }
        
        detailsRow.appendChild(detailsCell);
        return detailsRow;
    }

    // Add these helper methods
    groupIssuesByRow(issues) {
        return issues.reduce((groups, issue) => {
            const rowIndex = issue.affectedProducts[0];
            if (!groups[rowIndex]) {
                groups[rowIndex] = [];
            }
            groups[rowIndex].push(issue);
            return groups;
        }, {});
    }

    countIssuesByType(issues, type, exclusive = false) {
        if (!exclusive) {
            return issues.filter(issue => issue.field === type).length;
        }
        
        // Count rows that only have this type of issue
        const issuesByRow = this.groupIssuesByRow(issues);
        return Object.values(issuesByRow).filter(rowIssues => 
            rowIssues.length === 1 && rowIssues[0].field === type
        ).length;
    }

    countRowsWithBothIssues(issuesByRow) {
        return Object.values(issuesByRow).filter(rowIssues => 
            rowIssues.some(issue => issue.field === 'title') && 
            rowIssues.some(issue => issue.field === 'description')
        ).length;
    }

    formatIssuesList(issues, issuesByRow) {
        if (!issues || !issuesByRow) {
            console.error('Missing issues data:', { issues, issuesByRow });
            return '';
        }

        return Object.entries(issuesByRow).map(([rowIndex, rowIssues]) => `
            <div class="issue-item" data-row="${rowIndex}" data-fields="${rowIssues.map(i => i.field).join(',')}">
                <div class="issue-header">
                    <span class="issue-count">${rowIssues.length > 1 ? 'Multiple Issues' : 'Single Issue'}</span>
                    <a href="#" class="row-link" data-row="${rowIndex}">Go to Row ${rowIndex}</a>
                </div>
                ${rowIssues.map(issue => `
                    <div class="issue-detail" data-field="${issue.field}" data-row="${rowIndex}">
                        <span class="issue-type">${issue.type}</span>
                        <div class="issue-message">${issue.message}</div>
                        <div class="issue-field">Field: ${issue.field}</div>
                    </div>
                `).join('')}
            </div>
        `).join('');
    }

    // Add the makeDraggable function to PopupManager class
    makeDraggable(element) {
        const header = element.querySelector('.panel-header');
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        header.addEventListener('mousedown', (e) => {
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            
            if (e.target === header) {
                isDragging = true;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                xOffset = currentX;
                yOffset = currentY;
                
                element.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }

    handleValidateClick() {
        console.log('[Monitor] validation: started');
        
        // Get current feed data
        const feedData = this.getCurrentFeedData();
        if (!feedData?.length) {
            console.error('No feed data available');
            return;
        }

        // Run analysis in background without showing UI
        const analysisResults = this.feedAnalyzer.analyzeFeed(feedData);
        
        // Show validation panel with results
        this.handleViewDetails('FEED-' + Date.now(), {
            issues: analysisResults.issues,
            totalProducts: feedData.length
        });
    }

    createValidationPanel(feedId, data) {
        // Create issuesByRow first
        const issuesByRow = this.groupIssuesByRow(data.issues);

        const panel = document.createElement('div');
        panel.className = 'floating-validation-panel';
        panel.dataset.feedId = feedId;
        
        panel.innerHTML = `
            <div class="panel-header">
                <h3>Validation Issues</h3>
                <button class="close-panel">&times;</button>
            </div>
            <div class="validation-summary">
                <span class="issue-count">${data.issues.length} Issues Found</span>
                <span class="feed-id">Feed ID: ${feedId}</span>
            </div>
            <div class="issues-container">
                <div class="quick-filters">
                    <button class="filter-btn active" data-filter="all">
                        All Issues (${data.issues.length})
                    </button>
                    <button class="filter-btn" data-filter="title-only">
                        Title Only (${this.countIssuesByType(data.issues, 'title', true)})
                    </button>
                    <button class="filter-btn" data-filter="description-only">
                        Description Only (${this.countIssuesByType(data.issues, 'description', true)})
                    </button>
                    <button class="filter-btn" data-filter="both">
                        Both Issues (${this.countRowsWithBothIssues(issuesByRow)})
                    </button>
                </div>
                <div class="issues-list">
                    ${this.formatIssuesList(data.issues, issuesByRow)}
                </div>
            </div>
        `;

        // Add event listeners for filters
        panel.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const filterType = btn.dataset.filter;
                const issueItems = panel.querySelectorAll('.issue-item');
                
                // Remove active class from all buttons
                panel.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                btn.classList.add('active');
                
                issueItems.forEach(item => {
                    const fields = item.dataset.fields?.split(',') || [];
                    const show = filterType === 'all' || 
                               (filterType === 'title-only' && fields.length === 1 && fields.includes('title')) ||
                               (filterType === 'description-only' && fields.length === 1 && fields.includes('description')) ||
                               (filterType === 'both' && fields.includes('title') && fields.includes('description'));
                    
                    item.style.display = show ? '' : 'none';
                });
            });
        });

        // Setup close button
        const closeBtn = panel.querySelector('.close-panel');
        closeBtn.addEventListener('click', () => {
            panel.remove();
            this.activeValidationPanel = null;
        });

        // Make panel draggable
        this.makeDraggable(panel);

        // Add to document and store reference
        document.body.appendChild(panel);
        this.activeValidationPanel = panel;

        // Setup row navigation
        this.setupRowNavigation(panel);

        return panel;
    }

    getCurrentFeedData() {
        // Delegate to FeedManager to get data from the table it manages
        if (!this.feedManager) {
            console.error("FeedManager not initialized in getCurrentFeedData!");
            return [];
        }
        return this.feedManager.getTableData();
    }

    updateValidationHistory(feedId, results) {
        const historyTable = document.getElementById('validationHistory');
        if (!historyTable) {
            console.error('Validation history table not found');
            return;
        }

        // Create new history row
        const row = document.createElement('tr');
        const timestamp = new Date().toLocaleTimeString();
        
        row.setAttribute('data-feed-id', feedId);
        row.innerHTML = `
            <td>${timestamp}</td>
            <td>${feedId}</td>
            <td>
                <span class="status-badge ${results.isValid ? 'success' : 'error'}">
                    ${results.isValid ? 'Success' : 'Failed'}
                </span>
            </td>
            <td>${results.issues?.length || 0}</td>
            <td>
                <button class="view-details-btn" data-feed-id="${feedId}">
                    View Details
                </button>
            </td>
        `;

        // Add click handler for view details button
        const viewDetailsBtn = row.querySelector('.view-details-btn');
        if (viewDetailsBtn) {
            viewDetailsBtn.addEventListener('click', () => {
                this.handleViewDetails(feedId, results);
            });
        }

        // Insert at the beginning of the table
        if (historyTable.querySelector('tbody')) {
            historyTable.querySelector('tbody').insertBefore(row, historyTable.querySelector('tbody').firstChild);
        } else {
            historyTable.insertBefore(row, historyTable.firstChild);
        }
    }

    // Add this new method to update the validation panel when issues are fixed
    updateValidationPanelIssues(feedId, fieldToFix, rowIndex) {
        if (!this.activeValidationPanel) return;
        
        // Remove the issue from the panel
        const issueToRemove = this.activeValidationPanel.querySelector(
            `.issue-item[data-row="${rowIndex}"] .issue-detail[data-field="${fieldToFix}"]`
        );

        if (issueToRemove) {
            const issueItem = issueToRemove.closest('.issue-item');
            issueToRemove.remove();

            // Check if there are any remaining issues in this item
            const remainingIssues = issueItem.querySelectorAll('.issue-detail');
            if (remainingIssues.length === 0) {
                issueItem.remove();
            } else {
                // Update the issue count text
                const countEl = issueItem.querySelector('.issue-count');
                if (countEl) {
                    countEl.textContent = remainingIssues.length > 1 ? 'Multiple Issues' : 'Single Issue';
                }
            }

            // Update the total count in the header
            const totalIssues = this.activeValidationPanel.querySelectorAll('.issue-detail').length;
            const issueCountEl = this.activeValidationPanel.querySelector('.validation-summary .issue-count');
            if (issueCountEl) {
                issueCountEl.textContent = `${totalIssues} Issues Found`;
            }

            // Update the filter buttons
            this.updateFilterCounts();

            // If no issues left, show success message
            if (totalIssues === 0) {
                this.activeValidationPanel.innerHTML = `
                    <div class="panel-header">
                        <h3>Validation Issues</h3>
                        <button class="close-panel">&times;</button>
                    </div>
                    <div class="validation-summary success">
                        <span class="issue-count">All Issues Resolved! 🎉</span>
                    </div>
                `;

                // Re-attach close button listener
                const closeBtn = this.activeValidationPanel.querySelector('.close-panel');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        this.activeValidationPanel.remove();
                        this.activeValidationPanel = null;
                    });
                }
            }
        }
    }

    updateFilterCounts() {
        if (!this.activeValidationPanel) return;
        
        const titleOnlyCount = this.activeValidationPanel.querySelectorAll('.issue-item[data-fields="title"]').length;
        const descOnlyCount = this.activeValidationPanel.querySelectorAll('.issue-item[data-fields="description"]').length;
        const bothCount = this.activeValidationPanel.querySelectorAll('.issue-item[data-fields="title,description"]').length;
        const totalCount = this.activeValidationPanel.querySelectorAll('.issue-item').length;
        
        // Update the filter buttons
        const filters = this.activeValidationPanel.querySelectorAll('.filter-btn');
        filters.forEach(btn => {
            const type = btn.dataset.filter;
            switch(type) {
                case 'all':
                    btn.textContent = `All Issues (${totalCount})`;
                    break;
                case 'title-only':
                    btn.textContent = `Title Only (${titleOnlyCount})`;
                    break;
                case 'description-only':
                    btn.textContent = `Description Only (${descOnlyCount})`;
                    break;
                case 'both':
                    btn.textContent = `Both Issues (${bothCount})`;
                    break;
            }
        });
    }

    // Add these new methods
    initializeSearch() {
        // Get search elements
        this.searchInput = document.getElementById('searchInput');
        this.searchColumn = document.getElementById('searchColumn');
        this.searchType = document.getElementById('searchType');
        
        if (this.searchInput && this.searchColumn && this.searchType) {
            // Initialize column dropdown with actual table headers
            this.updateSearchColumns();
            
            // Add listeners with debounce for performance
            this.searchInput.addEventListener('input', debounce(() => {
                this.handleSearch();
            }, 300));
            
            // Add enter key handler
            this.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.handleSearch();
                }
            });
            
            this.searchColumn.addEventListener('change', () => this.handleSearch());
            this.searchType.addEventListener('change', () => this.handleSearch());
        } else {
            console.error('Search elements not found:', { // Keep the error log from original code
                input: !!this.searchInput,
                column: !!this.searchColumn,
                type: !!this.searchType
            });
        }
    } // <--- ADDED MISSING CLOSING BRACE FOR initializeSearch()
    // --- Search methods removed - logic moved to SearchManager ---

    /**
     * Verifies GMC connection status or initiates authentication if needed.
     */
    async verifyOrAuthenticateGMC() {
        this.loadingManager.showLoading('Checking GMC Connection...');
        try {
            let message = '';
            // Re-initialize to be sure we have the latest stored state
            await this.gmcApi.initialize();

            if (this.gmcApi.isAuthenticated) {
                // Optional: Could make a quick test call like fetchMerchantInfo again
                // to ensure the token is still valid, but chrome.identity handles refresh.
                console.log('Already authenticated. Merchant ID:', this.gmcApi.merchantId);
                message = `Already connected to GMC (Merchant ID: ${this.gmcApi.merchantId})`;
                this.errorManager.showSuccess(message, 3000);
                this.updateStatusBarUI(); // Ensure UI is up-to-date
            } else {
                console.log('Not authenticated, attempting to authenticate...');
                const success = await this.gmcApi.authenticate();
                if (success) {
                    message = `Successfully connected to GMC (Merchant ID: ${this.gmcApi.merchantId})`;
                    this.errorManager.showSuccess(message, 3000);
                    this.statusBarManager.updateUI(); // Update UI after successful auth
                } else {
                    // Should not be reached if authenticate throws on error
                    message = 'Authentication failed. Please try again.';
                    this.errorManager.showError(message);
                    this.updateStatusBarUI(true); // Update UI to reflect error state
                }
            }
        } catch (error) {
            console.error('GMC connection/authentication failed:', error);
            let errorMessage = 'Could not connect to GMC.';
            if (error.message && error.message.includes('No merchant account found')) {
                errorMessage = 'Connection failed: No Google Merchant Center account found or accessible.';
            } else if (error.message) {
                errorMessage = `Connection failed: ${error.message}`;
            }
            this.errorManager.showError(errorMessage);
            this.statusBarManager.updateUI(true); // Update UI to reflect error state
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    /**
     * Handles the logout process.
     */
    async handleLogout() {
        console.log('Logout button clicked');
        this.loadingManager.showLoading('Logging out...');
        try {
            await this.gmcApi.logout();
            this.errorManager.showSuccess('Successfully logged out.', 2000);
            this.statusBarManager.updateUI(); // Update UI to logged-out state
            // Optional: Disable buttons that require auth? (Handled in updateStatusBarUI)
            // Optional: Redirect to login.html?
            // Consider closing the tab instead if opened from login.html
            // window.close(); // Or chrome.tabs.remove(tabId); if you have the tab ID
        } catch (error) {
            console.error('Logout failed:', error);
            this.errorManager.showError(`Logout failed: ${error.message}`);
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    /**
     * Updates the status bar UI based on authentication state.
     * @param {boolean} [isError=false] - Flag to indicate an error state.
     */
    updateStatusBarUI(isError = false) {
        if (!this.statusBar) {
            // Attempt to set it up if not already done (e.g., if initialize failed early)
            this.setupStatusBar();
            if (!this.statusBar) {
                console.error('Status bar element not found, cannot update UI.');
                return;
            }
        }

        const { merchantInfo, modeIndicator } = this.statusBar;
        const merchantValueEl = merchantInfo?.querySelector('.merchant-value');
        const statusDotEl = modeIndicator?.querySelector('.status-dot');
        const statusTextEl = modeIndicator?.querySelector('.status-text');

        // Ensure elements exist before trying to update them
        if (!merchantValueEl || !statusDotEl || !statusTextEl) {
            console.error('Status bar sub-elements not found.');
            return;
        }

        // Ensure buttons exist before trying to update them
        const verifyBtn = this.verifyGMCButton || document.getElementById('verifyGMCConnection');
        const validateBtn = this.validateGMCButton || document.getElementById('validateGMC');
        const logoutBtn = this.logoutButton || document.getElementById('logoutButton');

        if (isError) {
            merchantValueEl.textContent = 'Error';
            merchantValueEl.style.color = '#dc3545'; // Red
            statusDotEl.className = 'status-dot error';
            statusTextEl.textContent = 'Connection Error';
            if(validateBtn) validateBtn.disabled = true;
            if(logoutBtn) logoutBtn.style.display = 'none';
            if(verifyBtn) verifyBtn.textContent = 'Retry Connection';

        } else if (this.gmcApi.isAuthenticated && this.gmcApi.merchantId) {
            merchantValueEl.textContent = this.gmcApi.merchantId;
            merchantValueEl.style.color = ''; // Reset color
            statusDotEl.className = 'status-dot live'; // Assume live if authenticated
            statusTextEl.textContent = 'Connected';
            // Enable buttons requiring auth
            if(validateBtn) validateBtn.disabled = false;
            if(logoutBtn) logoutBtn.style.display = ''; // Show logout
            if(verifyBtn) verifyBtn.textContent = 'GMC Connected'; // Change text

        } else {
            merchantValueEl.textContent = 'Not Connected';
            merchantValueEl.style.color = '#ffc107'; // Yellow/Orange
            statusDotEl.className = 'status-dot disconnected';
            statusTextEl.textContent = 'Disconnected';
            // Disable buttons requiring auth
            if(validateBtn) validateBtn.disabled = true;
            if(logoutBtn) logoutBtn.style.display = 'none'; // Hide logout
            if(verifyBtn) verifyBtn.textContent = 'Verify GMC Connection'; // Reset text
        }
    }

} // End of PopupManager class

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    new PopupManager();
});
