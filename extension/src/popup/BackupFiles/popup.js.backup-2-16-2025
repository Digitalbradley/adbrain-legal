// Utility function for debouncing 
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Character counter function
window.updateCharCount = function(element, maxLength) {
    const content = element.innerText || element.textContent;
    const charCount = content.length;
    const countDisplay = element.nextElementSibling;
    const isDescription = element.dataset.field === 'description';
    const minRequired = isDescription ? 90 : 25;
    
    countDisplay.textContent = `${charCount}/${maxLength}`;
    
    // Color the count red if under minimum
    if (charCount < minRequired) {
        countDisplay.style.color = '#dc3545'; // Red
    } else if (charCount > maxLength) {
        countDisplay.style.color = '#dc3545'; // Red
    } else {
        countDisplay.style.color = '#28a745'; // Green
    }
};

class MonitoringSystem {
    constructor() {
        this.currentVersion = '1.0.0';
        this.startTime = new Date();
        
        // Initialize storage for metrics
        this.metrics = {
            operations: [],
            errors: [],
            featureUsage: {}
        };
    }

    logOperation(operation, status, details = {}) {
        const entry = {
            timestamp: new Date(),
            operation,
            status,
            details,
            version: this.currentVersion
        };
        
        console.log(`[Monitor] ${operation}:`, status);
        this.metrics.operations.push(entry);
        
        // Track feature usage
        this.metrics.featureUsage[operation] = 
            (this.metrics.featureUsage[operation] || 0) + 1;
    }

    logError(error, context) {
        const entry = {
            timestamp: new Date(),
            context,
            error: error.message,
            stack: error.stack,
            version: this.currentVersion
        };
        
        console.error(`[Monitor] Error in ${context}:`, error);
        this.metrics.errors.push(entry);
    }
}

class PopupManager {
    constructor() {
        // Add monitoring system
        this.monitor = new MonitoringSystem();
        
        console.log('Initializing PopupManager');
        
        // Initialize managers with monitoring
        this.tableManager = new TableManager();
        this.loadingManager = new LoadingManager();
        this.errorManager = new ErrorManager();
        this.gmcApi = new GMCApi();
        this.gmcValidator = new GMCValidator(this.gmcApi);
        this.feedAnalyzer = new window.FeedAnalyzer(this.tableManager);
        
        // UI elements
        this.fileInput = document.getElementById('fileInput');
        this.previewButton = document.getElementById('previewFeed');
        this.exportButton = document.getElementById('exportFeed');
        this.mainDropdown = document.getElementById('mainDropdown');
        this.dataContainer = null;
        this.verifyGMCButton = document.getElementById('testGMCAuth');
        this.validateGMCButton = document.getElementById('validateGMC');
        
        this.setupEventListeners();
        this.debounceTimeout = null;
        this.setupScrollSync();
        this.setupTabs();

        // Add event delegation for validation history
        const validationHistory = document.getElementById('validationHistory');
        if (validationHistory) {
            validationHistory.addEventListener('click', (e) => {
                const viewDetailsBtn = e.target.closest('.view-details-btn');
                if (viewDetailsBtn) {
                    const feedId = viewDetailsBtn.dataset.feedId;
                    const row = viewDetailsBtn.closest('tr');
                    if (row && feedId) {
                        console.log('View Details clicked for feed:', feedId);
                        this.handleViewDetails(feedId, this.validationResults[feedId]);
                    }
                }
            });
        }

        // Add storage for active validation panel
        this.activeValidationPanel = null;
        
        // Add event delegation for table edits
        const previewContent = document.getElementById('previewContent');
        if (previewContent) {
            previewContent.addEventListener('input', (e) => {
                const editableField = e.target.closest('.editable-field');
                if (editableField) {
                    this.handleFieldEdit(editableField);
                }
            });
        }
    }

    initialize() {
        console.log('Initializing UI');
        this.setupElements();
        this.setupStatusBar();
        this.tableManager.initialize();
        this.setupScrollSync();
    }

    setupElements() {
        console.log('Setting up elements');
        
        this.dataContainer = document.querySelector('.data-container');

        if (!this.fileInput) console.error('File input not found');
        if (!this.previewButton) console.error('Preview button not found');
        if (!this.exportButton) console.error('Export button not found');
        if (!this.mainDropdown) console.error('Analysis dropdown not found');
        if (!this.dataContainer) console.error('Data container not found');
    }

    setupEventListeners() {
        console.log('Setting up event listeners');
        
        if (this.fileInput) {
            this.fileInput.addEventListener('change', () => {
                if (this.previewButton) {
                this.previewButton.disabled = !this.fileInput.files.length;
                }
            });
        }

        if (this.previewButton) {
            this.previewButton.addEventListener('click', () => this.handlePreview());
        }

        if (this.exportButton) {
            this.exportButton.addEventListener('click', () => this.handleExport());
        }

        if (this.mainDropdown) {
            this.mainDropdown.addEventListener('change', (e) => this.handleDropdownChange(e));
        }

        if (this.verifyGMCButton) {
            this.verifyGMCButton.addEventListener('click', () => this.testGMCAuth());
        }

        if (this.validateGMCButton) {
            this.validateGMCButton.addEventListener('click', () => this.validateWithGMC());
        }
    }

    async handlePreview() {
        try {
            this.monitor.logOperation('preview', 'started');
            
            if (!this.fileInput.files[0]) {
            this.errorManager.showError('Please select a file first');
                this.monitor.logOperation('preview', 'failed', { reason: 'no_file' });
            return;
        }

            this.loadingManager.showLoading('Processing feed...');
            
            // Read and parse the CSV file
            const csvText = await this.readFileAsText(this.fileInput.files[0]);
            const data = this.parseCSV(csvText);
            
            // Display the data
            await this.displayPreview(data);
            
            this.monitor.logOperation('preview', 'completed');
        } catch (error) {
            this.monitor.logError(error, 'handlePreview');
            this.errorManager.showError('Failed to preview file. Please check the format.');
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    async readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                // First try to detect the encoding
                const buffer = e.target.result;
                const decoder = new TextDecoder('utf-8', { fatal: true });
                
                try {
                    const text = decoder.decode(buffer);
                    resolve(text);
                } catch (encodingError) {
                    // If UTF-8 fails, try another common encoding
                    try {
                        const fallbackDecoder = new TextDecoder('iso-8859-1');
                        const text = fallbackDecoder.decode(buffer);
                        resolve(text);
                    } catch (fallbackError) {
                        reject(new Error('Unable to decode file content'));
                    }
                }
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    parseCSV(csvText) {
        // Normalize encoding first
        const normalized = csvText.normalize('NFKD')
            .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
            .replace(/[^\x00-\x7F]/g, '');   // Remove non-ASCII

        const lines = normalized.split('\n').filter(line => line.trim());
        
        // Get headers
        const headers = lines[0].split(',').map(h => h.trim());
        
        // Parse data rows
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;
            
            // Split the line by comma, handling quoted values
            const values = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
            
            // Create object from headers and values
                const row = {};
                headers.forEach((header, index) => {
                let value = values[index] || '';
                // Clean the value
                value = value
                    .replace(/^"|"$/g, '')  // Remove quotes
                    .trim();
                row[header] = value;
                });
                data.push(row);
        }
        
        return data;
    }

    async displayPreview(data) {
        const container = document.getElementById('previewContent');
        if (!container) return;

        const table = document.createElement('table');
        table.className = 'preview-table';

        // Get all unique headers from the data
        const headers = Object.keys(data[0] || {});
        
        // Create header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        headers.forEach(key => {
            const th = document.createElement('th');
            th.textContent = key;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Create body
        const tbody = document.createElement('tbody');
        data.forEach((row, index) => {
            const tr = document.createElement('tr');
            tr.id = `row-${index + 1}`;
            
            headers.forEach(key => {
                if (key === 'title' || key === 'description') {
                    tr.appendChild(this.createEditableCell(row[key] || '', key, index));
                } else {
                    const td = document.createElement('td');
                    td.textContent = row[key] || '';
                    tr.appendChild(td);
                }
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);

        container.innerHTML = '';
        container.appendChild(table);
    }

    handleDropdownChange(e) {
        const selectedValue = e.target.value;
        
        if (selectedValue === 'analyze-feed') {
                this.analyzeFeed();
        }
    }

    analyzeFeed() {
        const table = document.querySelector('.preview-table');
        if (!table) {
            alert('Please load and preview a feed first before analyzing.');
            return;
        }

        try {
            // Get headers from the table
            const headers = Array.from(table.querySelectorAll('thead th'))
                .map(th => th.textContent.trim().toLowerCase());

            // Get all rows except header
            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const totalProducts = rows.length;
            
            // Initialize analysis object
            const analysis = {
                totalProducts,
                titleErrors: 0,      // < 25 chars
                titleWarnings: 0,    // 25-70 chars
                titleOptimal: 0,     // 70-150 chars
                titleTooLong: 0,     // > 150 chars
                titleIssues: 0,
                descriptionIssues: 0,
                missingImages: 0,
                invalidPrices: 0,
                categories: new Set(),
                titleLengthStats: {
                    underMinimum: 0,    // < 25
                    underOptimal: 0,    // 25-70
                    optimal: 0,         // 70-150
                    tooLong: 0          // > 150
                },
                titleLengths: [],
                descriptionLengths: [],
                duplicateTitles: new Map(),
                duplicateDescriptions: new Map(),
                allCapsCount: 0
            };

            // Find column indexes
            const titleIndex = headers.indexOf('title');
            const descriptionIndex = headers.indexOf('description');
            const imageUrlIndex = headers.indexOf('image_link');
            const priceIndex = headers.indexOf('price');
            const categoryIndex = headers.indexOf('google_product_category');

            // Analyze each row
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                
                const titleField = cells[titleIndex]?.querySelector('.editable-field')?.textContent.trim() || '';
                const descriptionField = cells[descriptionIndex]?.querySelector('.editable-field')?.textContent.trim() || '';
                const imageUrl = cells[imageUrlIndex]?.textContent.trim() || '';
                const price = cells[priceIndex]?.textContent.trim() || '';
                const category = cells[categoryIndex]?.textContent.trim() || '';

                // Updated title validation logic
                if (titleField.length < 25) {
                    analysis.titleErrors++;
                    analysis.titleLengthStats.underMinimum++;
                    analysis.titleIssues++;
                } else if (titleField.length < 70) {
                    analysis.titleWarnings++;
                    analysis.titleLengthStats.underOptimal++;
                } else if (titleField.length <= 150) {
                    analysis.titleOptimal++;
                    analysis.titleLengthStats.optimal++;
                } else {
                    analysis.titleTooLong++;
                    analysis.titleLengthStats.tooLong++;
                    analysis.titleIssues++;
                }

                // Keep existing description validation
                if (descriptionField.length < 150) {
                    analysis.descriptionIssues++;
                    analysis.descTooShort++;
                }
                if (descriptionField.length > 5000) {
                    analysis.descriptionIssues++;
                    analysis.descTooLong++;
                }

                // Track duplicates
                analysis.duplicateTitles.set(titleField, (analysis.duplicateTitles.get(titleField) || 0) + 1);
                analysis.duplicateDescriptions.set(descriptionField, (analysis.duplicateDescriptions.get(descriptionField) || 0) + 1);

                // Track categories
                if (category) {
                    category.split('>').forEach(cat => {
                        const trimmedCat = cat.trim();
                        if (trimmedCat) {
                            analysis.categories.add(trimmedCat);
                        }
                    });
                }

                // Check image URL
                if (!imageUrl.startsWith('https://')) {
                    analysis.missingImages++;
                }

                // Check price format
                if (price) {
                    const parts = price.trim().split(' ');
                    if (parts.length !== 2 || isNaN(parseFloat(parts[0])) || parts[1] !== 'USD') {
                        analysis.invalidPrices++;
                    }
                }

                // Track title length
                analysis.titleLengths.push(titleField.length);
                analysis.descriptionLengths.push(descriptionField.length);
            });

            this.displayAnalysisReport(analysis, rows);

        } catch (error) {
            console.error('Error analyzing feed:', error);
            alert('Error analyzing feed. Please try again.');
        }
    }

    displayAnalysisReport(analysis, rows) {
        const healthScore = Math.round((1 - (analysis.titleIssues + analysis.descriptionIssues)/(analysis.totalProducts * 2)) * 100);
        
        // Determine health score color
        let healthColor = '#27ae60'; // Green
        if (healthScore < 70) healthColor = '#e67e22'; // Orange
        if (healthScore < 50) healthColor = '#e74c3c'; // Red

        const analysisHtml = `
            <div class="analysis-report">
                <div class="report-header">
                    <h3>Feed Health Analysis</h3>
                    <button class="close-analysis" title="Close Analysis">×</button>
                </div>
                
                <div class="health-score">
                    <h4>Overall Feed Health</h4>
                    <div class="progress-bar">
                        <div class="progress" style="width: ${healthScore}%; background: ${healthColor}"></div>
                    </div>
                    <div class="score-text" style="color: ${healthColor}">${healthScore}% Healthy</div>
                </div>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <h4>Overall Stats</h4>
                        <p><strong>Total Products:</strong> ${analysis.totalProducts}</p>
                        <p><strong>Categories:</strong> ${analysis.categories.size}</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Content Health</h4>
                        <p>
                            <strong>Title Issues:</strong> 
                            <span class="validation-badge ${analysis.titleIssues > 0 ? 'error' : 'success'}">
                                ${analysis.titleIssues} (${Math.round(analysis.titleIssues/analysis.totalProducts*100)}%)
                            </span>
                        </p>
                        <p>
                            <strong>Description Issues:</strong> 
                            <span class="validation-badge ${analysis.descriptionIssues > 0 ? 'error' : 'success'}">
                                ${analysis.descriptionIssues} (${Math.round(analysis.descriptionIssues/analysis.totalProducts*100)}%)
                            </span>
                        </p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Technical Issues</h4>
                        <p>
                            <strong>Image Issues:</strong> 
                            <span class="validation-badge ${analysis.missingImages > 0 ? 'error' : 'success'}">
                                ${analysis.missingImages}
                            </span>
                        </p>
                        <p>
                            <strong>Price Issues:</strong> 
                            <span class="validation-badge ${analysis.invalidPrices > 0 ? 'error' : 'success'}">
                                ${analysis.invalidPrices}
                            </span>
                        </p>
                    </div>
                </div>

                ${this.generateIssuesList(rows)}
            </div>
        `;

        // Remove any existing analysis report
            const existingReport = document.querySelector('.analysis-report');
            if (existingReport) {
                existingReport.remove();
            }

        // Insert the analysis report before the data table
        const dataContainer = document.querySelector('.data-container');
        const analysisElement = document.createElement('div');
        analysisElement.innerHTML = analysisHtml;
        dataContainer.insertBefore(analysisElement, dataContainer.firstChild);

        this.setupAnalysisInteractivity();
    }

    generateIssuesList(rows) {
        const issues = [];
        
        rows.forEach((row, index) => {
            const titleField = row.querySelector('.title-field')?.textContent.trim() || '';
            const descriptionField = row.querySelector('.description-field')?.textContent.trim() || '';
            const rowIssues = [];

            // Only show critical issues
            if (titleField.length < 25) {
                rowIssues.push(`Title too short (${titleField.length} chars). Minimum 25 characters required for Google Shopping.`);
            }
            if (descriptionField.length < 70) {
                rowIssues.push(`Description too short (${descriptionField.length} chars). Minimum 70 characters required for Google Shopping.`);
            }

            if (rowIssues.length > 0) {
                issues.push(`
                    <div class="issue-item">
                        <strong class="row-link" data-row-id="row-${index + 1}">Row ${index + 1}</strong>
                        ${rowIssues.map(issue => `
                            <div class="issue-message" data-row-id="row-${index + 1}">- ${issue}</div>
                        `).join('')}
                    </div>
                `);
            }
        });

        return issues.length > 0 ? `
            <div class="issues-list">
                <h4>Critical Issues</h4>
                ${issues.join('')}
            </div>
        ` : '<div class="no-issues">No issues found! Your feed meets Google Shopping requirements.</div>';
    }

    setupAnalysisInteractivity() {
        // Add click handlers for row links
        document.querySelectorAll('.row-link, .issue-message').forEach(element => {
            element.addEventListener('click', (e) => {
                const rowId = e.target.getAttribute('data-row-id');
                this.scrollToTableRow(rowId);
            });
        });

        // Add close button handler
        const closeButton = document.querySelector('.close-analysis');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                const report = document.querySelector('.analysis-report');
                if (report) report.remove();
            });
        }
    }

    scrollToTableRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) {
            // Smooth scroll to row
            row.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center'
            });
            
            // Add highlight effect
            row.style.transition = 'background-color 0.3s ease-in-out';
            row.style.backgroundColor = '#fff3cd';
            
            setTimeout(() => {
                row.style.backgroundColor = '';
                // Clean up after animation
                setTimeout(() => {
                    row.style.transition = '';
                }, 300);
            }, 1500);
        }
    }

    async handleExport() {
        try {
            const table = document.querySelector('.data-table');
            if (!table) {
                this.errorManager.showError('Please load and preview a feed first before exporting.');
                return;
            }

            const feedData = this.getFeedDataFromTable(table);
            if (!feedData || !feedData.length) {
                this.errorManager.showError('No data to export');
                return;
            }

            // Convert to CSV
            const headers = Object.keys(feedData[0]);
            const csv = [
                headers.join(','),
                ...feedData.map(row => headers.map(header => {
                    const value = row[header] || '';
                    return value.includes(',') ? `"${value}"` : value;
                }).join(','))
            ].join('\n');

            // Create download link
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'exported_feed.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            this.errorManager.showError('Feed exported successfully!', 3000);
        } catch (error) {
            console.error('Export failed:', error);
            this.errorManager.showError('Failed to export feed');
        }
    }

    getFeedDataFromTable(table) {
        const headerCells = Array.from(table.querySelectorAll('tr:first-child th'));
        const headerMap = new Map();
        
        headerCells.forEach((th, index) => {
            const headerName = th.textContent.trim().toLowerCase();
            if (headerName && headerName !== '#') {
                headerMap.set(headerName, index);
            }
        });

        const rows = Array.from(table.querySelectorAll('tr:not(.table-header)'));
        
        return rows.map(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            const rowData = {};
            
            headerMap.forEach((columnIndex, headerName) => {
                const cell = cells[columnIndex];
                if (cell) {
                    const editableField = cell.querySelector('.editable-field');
                    const value = editableField ? 
                        editableField.textContent.trim() : 
                        cell.textContent.trim();
                    
                    if (value) {
                        rowData[headerName] = value;
                    }
                }
            });
            
            return rowData;
        }).filter(row => Object.keys(row).length > 0);
    }

    async testGMCAuth() {
        try {
            this.loadingManager.showLoading('Verifying GMC Connection...');
            await this.gmcApi.authenticate();
            
            const successMessage = this.testMode ? 
                `Connected to GMC (Test Account: ${this.gmcApi.merchantId})` :
                `Connected to GMC (Merchant ID: ${this.gmcApi.merchantId})`;
                
            this.errorManager.showSuccess(successMessage, 3000);
        } catch (error) {
            console.error('GMC connection failed:', error);
            this.errorManager.showError('Could not connect to GMC: ' + error.message);
        } finally {
            this.loadingManager.hideLoading();
        }
    }

    showValidationProgress() {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        
        const progress = document.createElement('div');
        progress.className = 'validation-progress';
        progress.innerHTML = `
            <h3>Validating Feed</h3>
            <div class="progress-bar"></div>
            <div class="progress-text">Processing...</div>
        `;
        
        document.body.appendChild(overlay);
        document.body.appendChild(progress);
        return { overlay, progress };
    }

    async validateWithGMC() {
        try {
            this.monitor.logOperation('validation', 'started');
            
            console.log('=== Starting Validation Process ===');
            
            // Generate feedId at the start
            const feedId = `FEED-${Date.now().toString().slice(-6)}`;
            
            // Switch to validation tab first
            const validationTab = document.querySelector('[data-tab="validation"]');
            if (validationTab) {
                validationTab.click();
            }
            
            const previewContent = document.getElementById('previewContent');
            const table = previewContent?.querySelector('table');
            
            if (!table) {
                console.error('No data table found');
                return;
            }

            // Get feed data and analyze it
            const feedData = this.getFeedDataFromTable(table);
            console.log('Feed Data:', {
                rowCount: feedData.length,
                sampleRow: feedData[0],
                allRows: feedData  // Log all rows to see the data
            });
            
            // Get analysis results
            console.log('Running Feed Analysis...');
            const analysisResults = await this.feedAnalyzer.analyzeFeed(feedData);
            
            // Detailed logging of analysis results
            console.log('Analysis Results (Detailed):', {
                full: analysisResults,
                contentHealth: {
                    titleIssues: analysisResults.contentHealth?.titleIssues,
                    descriptionIssues: analysisResults.contentHealth?.descriptionIssues,
                    priceIssues: analysisResults.contentHealth?.priceIssues
                },
                criticalIssues: analysisResults.criticalIssues,
                rawIssues: analysisResults.issues,
                issueTypes: analysisResults.issues?.map(i => i.type),
                issueMessages: analysisResults.issues?.map(i => i.message)
            });

            // Let's also check the FeedAnalyzer class
            console.log('FeedAnalyzer Instance:', this.feedAnalyzer);
            
            // Format validation results
            const results = {
                isValid: false,
                totalProducts: feedData.length,
                issues: []
            };

            // Add issues from analysis
            if (analysisResults.criticalIssues) {
                console.log('Processing Critical Issues:', analysisResults.criticalIssues);
                results.issues.push(...analysisResults.criticalIssues);
            }

            if (analysisResults.contentHealth?.issues) {
                console.log('Processing Content Health Issues:', analysisResults.contentHealth.issues);
                results.issues.push(...analysisResults.contentHealth.issues);
            }

            // Update final validation status
            results.isValid = results.issues.length === 0;
            console.log('Final Validation Results:', {
                isValid: results.isValid,
                totalIssues: results.issues.length,
                issues: results.issues
            });

            // Update validation history
            const historyTable = document.getElementById('validationHistory');
            if (historyTable) {
                console.log('Updating Validation History...');
                const row = document.createElement('tr');
                const timestamp = new Date().toLocaleTimeString();
                
                // Add data-feed-id attribute to the row
                row.setAttribute('data-feed-id', feedId);
                
                row.innerHTML = `
                    <td>${timestamp}</td>
                    <td>${feedId}</td>
                    <td><span class="status-badge ${results.isValid ? 'success' : 'error'}">${results.isValid ? 'Success' : 'Failed'}</span></td>
                    <td>${results.issues?.length || 0}</td>
                    <td><button class="view-details-btn" data-feed-id="${feedId}">View Details</button></td>
                `;
                
                // Store results with feedId first
                this.validationResults = this.validationResults || {};
                this.validationResults[feedId] = results;
                
                // Then add the row to the table
                historyTable.insertBefore(row, historyTable.firstChild);
            }

            this.monitor.logOperation('validation', 'completed', {
                totalProducts: feedData.length,
                issuesFound: results.issues.length
            });

        } catch (error) {
            this.monitor.logError(error, 'validateWithGMC');
            this.errorManager.showError(error.message);
        }
    }

    showValidationResults(results) {
        // Add overlay
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        document.body.appendChild(overlay);

        const resultsEl = document.createElement('div');
        resultsEl.className = 'validation-results';
        resultsEl.innerHTML = `
            <div class="results-header">
                <h3>Validation Results</h3>
                <button class="close-results">×</button>
            </div>
            <div class="results-content">
                <div class="results-summary">
                    <div class="summary-item">
                        <span class="label">Total Products:</span>
                        <span class="value">${results.totalProducts}</span>
                    </div>
                    <div class="summary-item">
                        <span class="label">Valid Products:</span>
                        <span class="value">${results.validProducts}</span>
                    </div>
                    <div class="summary-item">
                        <span class="label">Issues Found:</span>
                        <span class="value">${results.issues.length}</span>
                    </div>
                </div>
                ${this.formatValidationIssues(results.issues)}
            </div>
        `;

        document.body.appendChild(resultsEl);

        // Add close handler
        resultsEl.querySelector('.close-results').addEventListener('click', () => {
            overlay.remove();
            resultsEl.remove();
        });

        // Close on overlay click
        overlay.addEventListener('click', () => {
            overlay.remove();
            resultsEl.remove();
        });
    }

    formatValidationIssues(issues) {
        if (!issues.length) return '<p class="no-issues">No issues found!</p>';

        return `
            <div class="issues-list">
                ${issues.map(issue => `
                    <div class="issue-item ${issue.severity}">
                        <div class="issue-header">
                            <span class="issue-id">Product ID: ${issue.productId}</span>
                            <span class="issue-severity">${issue.severity}</span>
                        </div>
                        <div class="issue-message">${issue.message}</div>
                        <div class="issue-field">Field: ${issue.field}</div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    checkErrors() {
        this.errorManager.showError('Error checking is a PRO feature. Please upgrade to access this functionality.');
    }

    viewSummary() {
        this.errorManager.showError('Feed summary is a PRO feature. Please upgrade to access this functionality.');
    }

    // Add debounce helper
    debounce(func, wait) {
        clearTimeout(this.debounceTimeout);
        this.debounceTimeout = setTimeout(func, wait);
    }

    // Add text sanitization helper
    sanitizeText(text) {
        return text
            // First normalize the text to handle composite characters
            .normalize('NFKD')
            // Replace common problematic characters
            .replace(/[\u2022]/g, '•')           // Proper bullet point
            .replace(/[\u2013\u2014]/g, '-')     // En and Em dashes
            .replace(/[\u201C\u201D]/g, '"')     // Smart quotes
            .replace(/[\u2018\u2019]/g, "'")     // Smart single quotes
            // Then clean up any remaining issues
            .replace(/â€¢/g, '•')                // Fix broken bullet points
            .replace(/â€œ|â€/g, '"')            // Fix broken quotes
            .replace(/â€™/g, "'")                // Fix broken apostrophes
            .replace(/\s+/g, ' ')                // Normalize spaces
            .trim();
    }

    createEditableCell(content, type, rowIndex) {
        const cell = document.createElement('td');
        const field = document.createElement('div');
        field.className = `editable-field ${type}-field`;
        field.contentEditable = true;
        field.dataset.field = type;
        field.textContent = this.sanitizeText(content);

        // Add character count display
        const charCountDisplay = document.createElement('div');
        charCountDisplay.className = 'char-count';
        
        // Update maxLength - show 70 for titles
        const maxLength = type === 'description' ? 90 : 70;  // Changed from 150 to 70 for titles
        
        cell.appendChild(field);
        cell.appendChild(charCountDisplay);
        
        // Now initialize character count after elements are connected
        const currentLength = field.textContent.length;
        charCountDisplay.textContent = `${currentLength}/${maxLength}`;
        
        // Set initial color - simplified logic
        if (type === 'description') {
            charCountDisplay.style.color = currentLength >= 90 ? '#28a745' : '#dc3545';
        } else {
            charCountDisplay.style.color = currentLength >= 25 ? '#28a745' : '#dc3545';
        }

        // Update count on input
        field.addEventListener('input', () => {
            const currentContent = field.textContent;
            const currentCount = currentContent.length;
            charCountDisplay.textContent = `${currentCount}/${maxLength}`;
            
            // Simplified color logic
            if (type === 'description') {
                charCountDisplay.style.color = currentCount >= 90 ? '#28a745' : '#dc3545';
} else {
                charCountDisplay.style.color = currentCount >= 25 ? '#28a745' : '#dc3545';
            }
            
            this.debounce(() => this.analyzeFeed(), 500);
        });

        return cell;
    }

    setupScrollSync() {
        const dataContainer = document.querySelector('.data-container');
        const scrollThumb = document.querySelector('.scroll-thumb');
        const scrollTrack = document.querySelector('.scroll-track');
        
        if (!dataContainer || !scrollThumb || !scrollTrack) return;

        // Calculate scrollbar width once
        const scrollbarWidth = dataContainer.offsetWidth - dataContainer.clientWidth;

        // Update thumb width accounting for scrollbar
        const updateThumbWidth = () => {
            // Use offsetWidth to include scrollbar in calculation
            const containerWidth = dataContainer.offsetWidth - scrollbarWidth;
            const scrollRatio = containerWidth / dataContainer.scrollWidth;
            const thumbWidth = Math.max(scrollRatio * 100, 10); // Minimum 10% width
            scrollThumb.style.width = `${thumbWidth}%`;
        };

        // Initial setup
        updateThumbWidth();

        // Sync floating scroll with content
        dataContainer.addEventListener('scroll', () => {
            const maxScroll = dataContainer.scrollWidth - dataContainer.offsetWidth + scrollbarWidth;
            const scrollRatio = dataContainer.scrollLeft / maxScroll;
            const trackWidth = scrollTrack.clientWidth - scrollThumb.offsetWidth;
            const thumbPosition = scrollRatio * trackWidth;
            scrollThumb.style.transform = `translateX(${thumbPosition}px)`;
        });

        // Handle thumb drag
        let isDragging = false;
        let startX;
        let scrollLeft;

        scrollThumb.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.pageX - scrollThumb.offsetLeft;
            scrollLeft = dataContainer.scrollLeft;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            e.preventDefault();
            const x = e.pageX - scrollTrack.getBoundingClientRect().left;
            const walk = (x - startX) * (dataContainer.scrollWidth / scrollTrack.clientWidth);
            dataContainer.scrollLeft = scrollLeft + walk;
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Handle window resize
        window.addEventListener('resize', updateThumbWidth);
    }

    setupStatusBar() {
        const statusBar = document.createElement('div');
        statusBar.className = 'status-bar';
        
        // Create status components
        const modeIndicator = document.createElement('div');
        modeIndicator.className = 'status-item mode-indicator';
        modeIndicator.innerHTML = `
            <span class="status-dot ${this.gmcApi.testMode ? 'test' : 'live'}"></span>
            <span class="status-text">${this.gmcApi.testMode ? 'Test Mode' : 'Live Mode'}</span>
        `;

        const merchantInfo = document.createElement('div');
        merchantInfo.className = 'status-item merchant-info';
        merchantInfo.innerHTML = `
            <span class="merchant-label">Merchant ID:</span>
            <span class="merchant-value">${this.gmcApi.merchantId || 'Not Connected'}</span>
        `;

        const lastAction = document.createElement('div');
        lastAction.className = 'status-item last-action';
        lastAction.innerHTML = '<span class="action-text">Ready</span>';

        // Add components to status bar
        statusBar.appendChild(modeIndicator);
        statusBar.appendChild(merchantInfo);
        statusBar.appendChild(lastAction);

        // Insert after header, before controls
        const header = document.querySelector('.branding');
        header.parentNode.insertBefore(statusBar, header.nextSibling);

        // Store reference for updates
        this.statusBar = {
            element: statusBar,
            lastAction: lastAction,
            merchantInfo: merchantInfo,
            modeIndicator: modeIndicator
        };
    }

    updateStatus(action, success = true) {
        if (!this.statusBar) return;
        
        const { lastAction } = this.statusBar;
        lastAction.innerHTML = `
            <span class="action-text ${success ? 'success' : 'error'}">${action}</span>
        `;
        
        // Auto-clear after 3 seconds
        setTimeout(() => {
            lastAction.innerHTML = '<span class="action-text">Ready</span>';
        }, 3000);
    }

    setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabPanels = document.querySelectorAll('.tab-panel');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                console.log('Tab clicked:', button.dataset.tab);
                
                // Remove active class from all buttons and panels
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanels.forEach(panel => panel.classList.remove('active'));

                // Add active class to clicked button and corresponding panel
                button.classList.add('active');
                const panelId = `${button.dataset.tab}-tab`;
                console.log('Activating panel:', panelId);
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.classList.add('active');
                }
            });
        });
    }

    handleViewDetails(feedId, validationData) {
        console.log('View Details clicked:', { feedId, validationData });
        
        const validationPanel = document.createElement('div');
        validationPanel.className = 'floating-validation-panel';
        validationPanel.innerHTML = `
            <div class="panel-header">
                <h3>Validation Issues</h3>
                <button class="close-panel">×</button>
            </div>
            <div class="panel-content">
                <div class="validation-summary">
                    <span class="issue-count">${validationData.issues.length} Issues Found</span>
                    <span class="feed-id">Feed ID: ${feedId}</span>
                </div>
                <div class="issues-list">
                    ${this.formatIssuesList(validationData.issues)}
                </div>
            </div>
        `;

        document.body.appendChild(validationPanel);

        // Add click handlers for row links
        const rowLinks = validationPanel.querySelectorAll('.row-link');
        rowLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const rowIndex = parseInt(link.dataset.row);
                console.log('Jumping to row:', rowIndex);

                // 1. First switch to Feed Preview tab
                const feedPreviewBtn = document.querySelector('.tab-button[data-tab="preview"]');
                if (feedPreviewBtn) {
                    // Clear active state from all tabs
                    document.querySelectorAll('.tab-button').forEach(tab => {
                        tab.classList.remove('active');
                    });
                    
                    // Set preview tab as active
                    feedPreviewBtn.classList.add('active');
                    
                    // Show preview panel, hide others
                    document.querySelectorAll('.tab-panel').forEach(panel => {
                        panel.style.display = 'none';
                    });
                    
                    const previewPanel = document.getElementById('preview-tab');
                    if (previewPanel) {
                        previewPanel.style.display = 'block';
                    }
                    
                    // 2. Find and highlight the row
                    const targetRow = document.querySelector(`#previewContent tbody tr:nth-child(${rowIndex})`);
                    if (targetRow) {
                        // Add highlight
                        targetRow.classList.add('needs-fix');
                        
                        // Scroll the row into view
                        targetRow.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                        
                        // Setup field monitoring
                        const fieldToFix = link.closest('.issue-item').dataset.field;
                        const field = targetRow.querySelector(`[data-field="${fieldToFix}"]`);
                        
                        if (field) {
                            const checkAndRemoveHighlight = () => {
                                const content = field.textContent;
                                const minRequired = fieldToFix === 'description' ? 90 : 25;
                                if (content.length >= minRequired) {
                                    targetRow.classList.add('fix-complete');
                                    setTimeout(() => {
                                        targetRow.classList.remove('needs-fix', 'fix-complete');
                                    }, 1000);
                                }
                            };
                            
                            field.addEventListener('input', checkAndRemoveHighlight);
                        }
                    }
                }
            });
        });

        validationPanel.querySelector('.close-panel').addEventListener('click', () => {
            validationPanel.remove();
        });
    }

    createValidationDetails(data) {
        const detailsRow = document.createElement('tr');
        detailsRow.className = 'validation-details-row';
        
        const detailsCell = document.createElement('td');
        detailsCell.colSpan = 5;
        
        if (data.isValid) {
            detailsCell.innerHTML = `
                <div class="validation-details success">
                    <h4>Validation Successful</h4>
                    <div class="details-content">
                        <p>✅ All products meet GMC requirements</p>
                        <p>Total Products Validated: ${data.totalProducts}</p>
                        <button class="modern-button">Re-validate Feed</button>
                    </div>
                </div>
            `;
        } else {
            detailsCell.innerHTML = `
                <div class="validation-details error">
                    <h4>Validation Issues Found</h4>
                    <div class="details-content">
                        <div class="issues-list">
                            ${this.formatIssuesList(data.issues)}
                        </div>
                    </div>
                </div>
            `;
        }
        
        detailsRow.appendChild(detailsCell);
        return detailsRow;
    }

    formatIssuesList(issues) {
        return issues.map(issue => `
            <div class="issue-item" data-field="${issue.field}">
                <div class="issue-header">
                    <span class="issue-type">${issue.type}</span>
                    <a href="#" class="row-link" data-row="${issue.affectedProducts[0]}">Go to Row ${issue.affectedProducts[0]}</a>
                </div>
                <div class="issue-message">${issue.message}</div>
                <div class="issue-field">Field: ${issue.field}</div>
            </div>
        `).join('');
    }

    // Add the makeDraggable function to PopupManager class
    makeDraggable(element) {
        const header = element.querySelector('.panel-header');
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        header.addEventListener('mousedown', (e) => {
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            
            if (e.target === header) {
                isDragging = true;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                xOffset = currentX;
                yOffset = currentY;
                
                element.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }

    handleFieldEdit(field) {
        // Get row and field info
        const row = field.closest('tr');
        const rowIndex = Array.from(row.parentElement.children).indexOf(row);
        const fieldName = field.dataset.field;
        const newValue = field.textContent;

        // Update character count if it's a description field
        if (fieldName === 'description') {
            window.updateCharCount(field, 5000);
        }

        // Validate the specific field
        const validationResult = this.validateField(fieldName, newValue);
        
        // If we have an active validation panel, update it
        if (this.activeValidationPanel) {
            this.updateValidationPanel(rowIndex + 1, fieldName);
        }
    }

    validateField(fieldName, value) {
        // Use the same validation rules as the analyzer
        const rules = this.feedAnalyzer.rules[fieldName];
        if (rules?.validate) {
            return rules.validate(value);
        }
        return [];
    }

    updateValidationPanel(rowIndex, updatedField) {
        if (!this.activeValidationPanel) return;

        // Get current validation data
        const feedId = this.activeValidationPanel.dataset.feedId;
        const validationData = this.validationResults[feedId];
        
        // Get the field content to validate
        const row = document.querySelector(`#previewContent tr:nth-child(${rowIndex})`);
        const field = row?.querySelector(`[data-field="${updatedField}"]`);
        const content = field?.textContent || '';
        
        // Check if the field now passes validation
        const isValid = this.validateFieldContent(updatedField, content);
        
        if (isValid) {
            // Remove this specific issue from the list
            validationData.issues = validationData.issues.filter(issue => {
                return !(issue.affectedProducts.includes(rowIndex) && issue.field === updatedField);
            });
            
            // Update the panel content
            const issuesList = this.activeValidationPanel.querySelector('.issues-list');
            const issueCount = this.activeValidationPanel.querySelector('.issue-count');
            
            if (validationData.issues.length > 0) {
                issuesList.innerHTML = this.formatIssuesList(validationData.issues);
                issueCount.textContent = `${validationData.issues.length} Issues Found`;
            } else {
                // If no issues left, show success message
                this.activeValidationPanel.querySelector('.panel-content').innerHTML = `
                    <div class="validation-summary success">
                        <span class="issue-count">All Issues Resolved! 🎉</span>
                    </div>
                `;
            }
        }
    }

    validateFieldContent(fieldName, content) {
        const rules = this.feedAnalyzer.rules[fieldName];
        if (!rules) return true;
        
        if (fieldName === 'description') {
            return content.length >= 90;
        } else if (fieldName === 'title') {
            return content.length >= 25;
        }
        
        return true;
    }

    handleValidateClick() {
        console.log('[Monitor] validation: started');
        
        // Get current feed data
        const feedData = this.getCurrentFeedData();
        if (!feedData?.length) {
            console.error('No feed data available');
            return;
        }

        // Run analysis in background without showing UI
        const analysisResults = this.feedAnalyzer.analyzeFeed(feedData);
        
        // Show validation panel with results
        this.handleViewDetails('FEED-' + Date.now(), {
            issues: analysisResults.issues,
            totalProducts: feedData.length
        });
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    new PopupManager();
});
